// Generated by CoffeeScript 1.10.0
(function() {
  var EPS, STYLES, addSVG, align, appendSVG, arrayIdx, arrayLength, clearSVG, coeffsField, concat, drawArea, drawCircle, drawCycle, drawFlat, drawPath, drawPointedCycle, drawText, drawTwoBasis, errorField, evenSum, irrationalField, mat1, mat2, mat3, mat4, max, min, nextButton, prevButton, sepField, submitButton, sum, textButton, textOn, toValues, tryParseJSON, update;

  EPS = 0.000000001;

  sum = function(a, b) {
    return a + b;
  };

  max = function(a, b) {
    return Math.max(a, b);
  };

  min = function(a, b) {
    return Math.min(a, b);
  };

  concat = function(a, b) {
    return a.concat(b);
  };

  STYLES = '.line  { fill: none; stroke-width: 3; stroke-linecap: round; stroke-linejoin: round; } .line.red   { stroke: red; } .line.blue  { stroke: blue; } .line.black { stroke: black; } .point { stroke: none; } .point.red   { fill: red; } .point.blue  { fill: blue; } .point.black { fill: black; } .text { font-family: monospace; font-size: 10; } .text.red   { fill: red; } .text.blue  { fill: blue; } .text.black { fill: black; } .svg { border-style: solid; border-width: 2px; background-color: #EEE; }';

  mat1 = {
    width: 340,
    height: 200,
    origin: [30, 30],
    scale: [260, 50]
  };

  mat2 = {
    width: 340,
    height: 200,
    origin: [30, 30],
    scale: [260, 130]
  };

  mat3 = {
    width: 340,
    height: 200,
    origin: [30, 30],
    scale: [260, 50]
  };

  mat4 = {
    width: 340,
    height: 200,
    origin: [30, 30],
    scale: [260, 130]
  };

  submitButton = {};

  textButton = {};

  prevButton = {};

  nextButton = {};

  drawArea = {};

  irrationalField = {};

  coeffsField = {};

  sepField = {};

  errorField = {};

  textOn = true;

  arrayIdx = 0;

  arrayLength = 1;

  window.onload = function() {
    submitButton = document.getElementById('submit');
    textButton = document.getElementById('textToggle');
    prevButton = document.getElementById('prev');
    nextButton = document.getElementById('next');
    drawArea = document.getElementById('draw');
    irrationalField = document.getElementById('irrational');
    coeffsField = document.getElementById('coeffs');
    sepField = document.getElementById('sep');
    errorField = document.getElementById('error');
    irrationalField.value = "" + E;
    coeffsField.value = '[[[4,-1],[1,0],[0,1],[3,0]], [[4,-1],[1,-0.25],[0,0.25],[0,0.25],[0,0.75],[3,0]], [[4,-1],[1,-0.25], [0,0.5],[0,0.25],[0,0.5],[3,0]], [[4,-1],[1,-0.25],[0,0.75],[0,0.25],[0,0.25],[3,0]], [[4,-1],[1,-0.25],[0,1],[3,0.25]], [[3,-0.75],[1,-0.25],[1,0.75],[3,0.25]], [[2,-0.5],[1,-0.25],[2,0.5],[3,0.25]], [[1,-0.25],[1,-0.25],[3,0.25],[3,0.25]], [[4,0],[4,0]]]';
    prevButton.value = "Prev";
    nextButton.value = "[" + arrayIdx + "] Next";
    sepField.value = '0.3';
    addSVG(mat1, appendSVG(drawArea, 'svg'));
    addSVG(mat2, appendSVG(drawArea, 'svg'));
    addSVG(mat3, appendSVG(drawArea, 'svg'));
    addSVG(mat4, appendSVG(drawArea, 'svg'));
    update();
    submitButton.addEventListener('click', (function(_this) {
      return function() {
        arrayIdx = 0;
        arrayLength = 1;
        return update();
      };
    })(this));
    textButton.addEventListener('click', (function(_this) {
      return function() {
        textOn = !textOn;
        return update();
      };
    })(this));
    prevButton.addEventListener('click', (function(_this) {
      return function() {
        arrayIdx = (arrayIdx + arrayLength - 1) % arrayLength;
        prevButton.value = "Prev";
        return update();
      };
    })(this));
    nextButton.addEventListener('click', (function(_this) {
      return function() {
        arrayIdx = (arrayIdx + 1) % arrayLength;
        nextButton.value = "[" + arrayIdx + "] Next";
        return update();
      };
    })(this));
    return null;
  };

  update = function() {
    var cs, data, input, irr, sep;
    errorField.innerHTML = '';
    if (!(irr = tryParseJSON(irrationalField, 'x = '))) {
      return;
    }
    if (!(sep = tryParseJSON(sepField, 'Seperation '))) {
      return;
    }
    if (!(data = tryParseJSON(coeffsField, 'Length '))) {
      return;
    }
    arrayLength = data.length;
    clearSVG(mat1.svg);
    clearSVG(mat2.svg);
    clearSVG(mat3.svg);
    clearSVG(mat4.svg);
    cs = data[(arrayIdx + arrayLength - 1) % arrayLength];
    input = {
      basis: [1, irr],
      coeffs: cs
    };
    drawFlat(mat1, input, sep, {
      "class": 'red line'
    });
    drawTwoBasis(mat2, input, {
      "class": ' red line'
    });
    input.coeffs = data[arrayIdx];
    drawFlat(mat3, input, sep, {
      "class": 'blue line'
    });
    return drawTwoBasis(mat4, input, {
      "class": 'blue line'
    });
  };

  tryParseJSON = function(field, str) {
    var error, error1, value;
    try {
      value = JSON.parse(field.value);
    } catch (error1) {
      error = error1;
      errorField.innerHTML = str + " input not valid";
      return false;
    }
    return value;
  };

  clearSVG = function(svg) {
    var results;
    results = [];
    while (svg.children[1]) {
      results.push(svg.removeChild(svg.children[1]));
    }
    return results;
  };

  toValues = function(ratBasArray) {
    var b, c, i;
    return (function() {
      var j, len, ref, results;
      ref = ratBasArray.coeffs;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        c = ref[j];
        results.push(((function() {
          var l, len1, ref1, results1;
          ref1 = ratBasArray.basis;
          results1 = [];
          for (i = l = 0, len1 = ref1.length; l < len1; i = ++l) {
            b = ref1[i];
            results1.push(c[i] * b);
          }
          return results1;
        })()).reduce(sum));
      }
      return results;
    })();
  };

  evenSum = function(array) {
    var d, i;
    return ((function() {
      var j, len, results;
      results = [];
      for (i = j = 0, len = array.length; j < len; i = ++j) {
        d = array[i];
        if ((i % 2) === 0) {
          results.push(d);
        }
      }
      return results;
    })()).reduce(sum);
  };

  drawTwoBasis = function(mat, ratBasArray, attrs) {
    var anchor, c, coords, coords_, d, dists, height, i, j, len, loc, maxX, maxY, minX, minY, scale, sgn, width, x, y;
    dists = toValues(ratBasArray);
    dists = (function() {
      var j, len, results;
      results = [];
      for (i = j = 0, len = dists.length; j < len; i = ++j) {
        d = dists[i];
        results.push((i % 2) === 0 ? d : -d);
      }
      return results;
    })();
    if (Math.abs(dists.reduce(sum)) > EPS) {
      errorField.innerHTML = 'Input is not flat foldable';
      return;
    }
    loc = [0, 0];
    coords = (function() {
      var j, len, ref, ref1, results;
      ref = ratBasArray.coeffs;
      results = [];
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        ref1 = ref[i], x = ref1[0], y = ref1[1];
        sgn = (i % 2) === 0 ? 1 : -1;
        loc = [loc[0] + x * sgn, loc[1] + y * sgn];
        results.push(loc);
      }
      return results;
    })();
    minX = ((function() {
      var j, len, results;
      results = [];
      for (j = 0, len = coords.length; j < len; j++) {
        d = coords[j];
        results.push(d[0]);
      }
      return results;
    })()).reduce(min);
    maxX = ((function() {
      var j, len, results;
      results = [];
      for (j = 0, len = coords.length; j < len; j++) {
        d = coords[j];
        results.push(d[0]);
      }
      return results;
    })()).reduce(max);
    width = maxX - minX;
    minY = ((function() {
      var j, len, results;
      results = [];
      for (j = 0, len = coords.length; j < len; j++) {
        d = coords[j];
        results.push(d[1]);
      }
      return results;
    })()).reduce(min);
    maxY = ((function() {
      var j, len, results;
      results = [];
      for (j = 0, len = coords.length; j < len; j++) {
        d = coords[j];
        results.push(d[1]);
      }
      return results;
    })()).reduce(max);
    height = maxY - minY;
    scale = Math.max(width, height);
    coords_ = (function() {
      var j, len, ref, results;
      results = [];
      for (j = 0, len = coords.length; j < len; j++) {
        ref = coords[j], x = ref[0], y = ref[1];
        results.push([(x - minX) / scale, (y - minY) / scale]);
      }
      return results;
    })();
    drawPointedCycle(mat, coords_, 3, attrs);
    drawCircle(mat, [-minX / scale, -minY / scale], 5, {
      "class": 'red point'
    });
    for (i = j = 0, len = coords.length; j < len; i = ++j) {
      c = coords[i];
      if (!(textOn)) {
        continue;
      }
      anchor = coords_[i];
      anchor[1] += 0.03;
      drawText(mat, anchor, "[" + c[0] + "," + c[1] + "]");
    }
    return null;
  };

  drawFlat = function(mat, ratBasArray, sep, attrs) {
    var anchor, c, coords, d, dists, i, j, len, loc, pts, sgn, width, x, y;
    dists = toValues(ratBasArray);
    dists = (function() {
      var j, len, results;
      results = [];
      for (i = j = 0, len = dists.length; j < len; i = ++j) {
        d = dists[i];
        results.push((i % 2) === 0 ? d : -d);
      }
      return results;
    })();
    if (Math.abs(dists.reduce(sum)) > EPS) {
      errorField.innerHTML = 'Input is not flat foldable';
      return;
    }
    width = evenSum(dists);
    loc = 0;
    pts = ((function() {
      var j, len, results;
      results = [];
      for (i = j = 0, len = dists.length; j < len; i = ++j) {
        d = dists[i];
        loc += d;
        results.push([[loc / width, i * sep], [loc / width, (i + 1) * sep]]);
      }
      return results;
    })()).reduce(concat);
    pts[pts.length - 1][1] = 0;
    drawPointedCycle(mat, pts, 3, attrs);
    drawCircle(mat, [0, 0], 5, {
      "class": 'red point'
    });
    loc = [0, 0];
    coords = (function() {
      var j, len, ref, ref1, results;
      ref = ratBasArray.coeffs;
      results = [];
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        ref1 = ref[i], x = ref1[0], y = ref1[1];
        sgn = (i % 2) === 0 ? 1 : -1;
        loc = [loc[0] + x * sgn, loc[1] + y * sgn];
        results.push(loc);
      }
      return results;
    })();
    for (i = j = 0, len = coords.length; j < len; i = ++j) {
      c = coords[i];
      if (!(textOn)) {
        continue;
      }
      anchor = pts[2 * i];
      anchor[0] += 0.01;
      anchor[1] += 0.1;
      drawText(mat, anchor, "[" + c[0] + "," + c[1] + "]: " + ((c[0] + c[1] * E).toFixed(2)));
    }
    return null;
  };

  addSVG = function(mat, svg) {
    mat.svg = svg;
    if (mat.width == null) {
      mat.width = 500;
    }
    if (mat.width == null) {
      mat.height = 500;
    }
    mat.svg.setAttribute('width', mat.width);
    mat.svg.setAttribute('height', mat.height);
    mat.svg.setAttribute('class', 'svg');
    mat.svg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
    mat.style = mat.svg.appendChild(document.createElement('style'));
    mat.style.setAttribute('type', 'text/css');
    mat.style.innerHTML = STYLES;
    return mat;
  };

  align = function(mat, pt) {
    return [pt[0] * mat.scale[0] + mat.origin[0], -pt[1] * mat.scale[1] - mat.origin[1] + mat.height];
  };

  appendSVG = function(container, tag, attrs) {
    var el, k, v;
    if (attrs == null) {
      attrs = {};
    }
    el = document.createElementNS('http://www.w3.org/2000/svg', tag);
    for (k in attrs) {
      v = attrs[k];
      el.setAttribute(k, v);
    }
    return container.appendChild(el);
  };

  drawCircle = function(mat, center, radius, attrs) {
    var c;
    if (attrs == null) {
      attrs = {
        "class": 'black point'
      };
    }
    c = align(mat, center);
    attrs.cx = c[0];
    attrs.cy = c[1];
    attrs.r = radius;
    return appendSVG(mat.svg, 'circle', attrs);
  };

  drawText = function(mat, center, str, attrs) {
    var c, svg;
    if (attrs == null) {
      attrs = {
        "class": 'black text'
      };
    }
    c = align(mat, center);
    attrs.x = c[0];
    attrs.y = c[1];
    svg = appendSVG(mat.svg, 'text', attrs);
    svg.innerHTML = str;
    return svg;
  };

  drawPath = function(mat, coords, attrs) {
    var c, i, j, len, p;
    if (attrs == null) {
      attrs = {
        "class": 'black line'
      };
    }
    attrs.d = 'M ';
    for (i = j = 0, len = coords.length; j < len; i = ++j) {
      c = coords[i];
      p = align(mat, c);
      attrs.d += (i !== 0 ? ' L ' : '') + p[0] + ' ' + p[1];
    }
    return appendSVG(mat.svg, 'path', attrs);
  };

  drawCycle = function(mat, coords, attrs) {
    return drawPath(mat, coords.concat([coords[0]]), attrs);
  };

  drawPointedCycle = function(mat, coords, rad, attrs) {
    var c, j, len;
    for (j = 0, len = coords.length; j < len; j++) {
      c = coords[j];
      drawCircle(mat, c, rad);
    }
    return drawCycle(mat, coords, attrs);
  };

}).call(this);
